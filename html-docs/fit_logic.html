<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qudi: How to use fitting in Qudi</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qudi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to use fitting in Qudi </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>First of all it is important to mention that the naming convention of methods is very important! Only if the methods are named right the automated import works properly!</p>
<p>General procedure to create new fitting routines:</p>
<p>A fitting routine consists of three major parts:</p><ol type="1">
<li>a (mathematical) model <code>make_&lt;custom&gt;_model()</code><ul>
<li>Here we use the lmfit package, which has a couple of standard models like ConstantModel, LorentzianModel or GaussianModel. These models can be used straight away and also can be added, like: new_model = ConstantModel()+GaussianModel(), which yields a Gaussian model with an offset.</li>
<li>If there is no standard model one can define a customized model, see make_sine_model()</li>
<li>With model.make_params() one can create a set of parameters with a value, min, max, vary and an expression. These parameters are returned as a Parameters object which contains all variables in a dictionary.</li>
<li>The make_"&lt;custom&gt;"_model method returns, the model and a corresponding parameter dictionary</li>
</ul>
</li>
<li>an estimator, which can extract initial values for the fitting routine from the passed data. <code>estimate_&lt;custom&gt;()</code><ul>
<li>Here values have to be estimated from the raw data</li>
<li>In many cases a clever convolution helps a lot</li>
<li>Offsets can be retrieved from find_offset_parameter method</li>
<li>All parameters are given via a Parameters object</li>
<li>The estimated values are returned inside a Parameters object</li>
</ul>
</li>
<li>The actual fit method <code>make_&lt;custom&gt;_fit()</code><ul>
<li>First the model and parameters are created with the make_model method.</li>
<li>The initial values are returned by the estimator method</li>
<li>Constraints are set, e.g. param['offset'].min=0 param['offset'].max=data.max()</li>
<li>Additional parameters given by inputs can be overwritten by substitute_parameter method</li>
<li>Finally fit is done via model.fit(data, x=axis,params=params)</li>
<li>The fit routine from lmfit returns a dictionary with many parameters like: results with errors and correlations, best_values, initial_values, success flag, an error message.</li>
<li>With model.eval(...) one can generate high resolution data by setting an x-axis with maby points</li>
</ul>
</li>
</ol>
<p>The power of that general splitting is that you can write pretty independent fit algorithms, but their efficiency will (very often) rely on the quality of the estimator.</p>
<h1>Naming convention:</h1>
<ol type="1">
<li>fit method: <code>make_&lt;custom&gt;_fit()</code> it is important to have no extra underscores, and that it starts with <code>make_</code> and ends with <code>_fit</code>. In order to distinguish between oneD and twoD models, every twoD model has to include the string twoD e.g. <pre class="fragment">    def make_gaussian_fit() and def make_twoDgaussian_fit()
</pre></li>
<li>estimate function: <code>estimate_&lt;custom&gt;()</code> e.g. <code>estimate_gaussian()</code> if you only have one estimator, if there are different estimators <code>estimate_&lt;custom&gt;_&lt;estimator name&gt;</code>. it is important to have no extra underscores, and that it starts with <code>estimate_</code>, e.g. <pre class="fragment">    def estimate_gaussian_dip() and def estimate_gaussian_peak()
</pre></li>
</ol>
<ol type="1">
<li>model function: <code>make_&lt;custom&gt;_model()</code>, if one wants to construct the model from a custom (not built-in) function one can do that within the <code>make_&lt;custom&gt;_model()</code>` method e.g. <pre class="fragment">       def make_sine_model(self):
           """ This method creates a model of sine.

           @return tuple: (object model, object params)
           """
           def sine_function(x, amplitude, frequency,phase):
               """
               Function of a sine.
               @param x: variable variable - e.g. time
               @param amplitude: amplitude
               @param frequency: frequency
               @param phase: phase

               @return: sine function: in order to use it as a model
               """

               return amplitude*np.sin(2*np.pi*frequency*x+phase)

           model = Model(sine_function, prefix='s0')

           params = model.make_params()

           return model, params
</pre></li>
</ol>
<h1>The model</h1>
<p>Useful methods usable from the model are: </p><pre class="fragment">model.eval(x=x_axis, parameters)
</pre><p>or </p><pre class="fragment">linear_model.eval(x=np.linspace(0,10,100), slope=2., offset=10.)
</pre><p>One can retrieve the independent and variable variables from a model with: </p><pre class="fragment"> model.param_names and model.independent_vars
</pre><p>More information here: <a href="https://lmfit.github.io/lmfit-py/model.html">https://lmfit.github.io/lmfit-py/model.html</a></p>
<h1>The returned object of the fit method</h1>
<p>In the object returned from the fit method many parameters are saved. Some useful values are listed here:</p>
<ul>
<li>a well readable fit_report <code>result.fit_report()</code></li>
<li>an array of the fit corresponding to the x axis: <code>result.best_fit</code></li>
<li>an array of the initial parameters corresponding to the x axis: <code>result.init_fit</code></li>
<li>a parameters dictionary of the fitted values: <code>result.best_values</code></li>
<li>a parameters dictionary of the initial values: <code>result.init_values</code></li>
<li>information about the fit: <code>result.message</code></li>
<li>a boolean which tells if the fit worked: <code>result.success</code></li>
</ul>
<p>More information at <a href="https://lmfit.github.io/lmfit-py/model.html">https://lmfit.github.io/lmfit-py/model.html</a></p>
<h1>Parameters object</h1>
<p>The parameter object can be created from a model: </p><pre class="fragment">    parameters = model.make_param()
</pre><p>It is also given back from the <code>make_&lt;custom&gt;_model()</code> method: </p><pre class="fragment">    model, parameters = make_&lt;custom&gt;_model()
</pre><p>Useful methods of the Parameters class are:</p><ul>
<li>add, e.g. parameters.add('frequency', value=1, vary=True, min=0, max=10,expr=None)</li>
<li>add_many <pre class="fragment">                     #(Name,       Value,      Vary,           Min,                             Max,                       Expr)
  params.add_many(('amplitude',   amplitude,  True,        100,                               1e7,                           None),
                 (  'sigma_x',    sigma_x,    True,        1*(stepsize_x) ,              3*(x_axis[-1]-x_axis[0]),          None),
                 (  'sigma_y',  sigma_y,      True,   1*(stepsize_y) ,                        3*(y_axis[-1]-y_axis[0]) ,   None),
                 (  'x_zero',    x_zero,      True,     (x_axis[0])-n_steps_x*stepsize_x ,         x_axis[-1]+n_steps_x*stepsize_x,               None),
                 (  'y_zero',     y_zero,     True,    (y_axis[0])-n_steps_y*stepsize_y ,         (y_axis[-1])+n_steps_y*stepsize_y,         None),
                 (  'theta',       0.,        True,           0. ,                             np.pi,               None),
                 (  'offset',      offset,    True,           0,                              1e7,                       None))
</pre></li>
</ul>
<p>Single changes can be set in the following way: </p><pre class="fragment">    params['amplitude'].min = 0.0
    params['amplitude'].max = 10.0
    params['lorentz1'].expr='lorentz0_center+2.15'
    params['amplitude'].vary = True
    params['amplitude'].value = 0.12
</pre><p>See very detailed description: <a href="https://lmfit.github.io/lmfit-py/parameters.html">https://lmfit.github.io/lmfit-py/parameters.html</a></p>
<h1>General functions</h1>
<ul>
<li>Searching a double dip in data: <pre class="fragment">_search_double_dip()
</pre></li>
<li>Search the end of a dip. This can be used to exclude a dip from data in order to find second dip, or one can estimate with this method the width of a dip/peak <pre class="fragment">    _search_end_of_dip()
</pre></li>
<li>Find offset from peaklike data, here first a lorentzian filter is applied on the data and the a histogram is made. The most frequent value is supposed to be the offset value: <pre class="fragment">    find_offset_parameter()
</pre></li>
<li>Smooth data with a gaussian filter, the filter is adjusted in size depending on the length of the input data: <pre class="fragment">    gaussian_smoothing()
</pre></li>
</ul>
<h1>List of fit functions</h1>
<p>This list can be read out in the manager console: </p><pre class="fragment">    fitlogic.oneD_fit_methods and fitlogic.twoD_fit_methods </pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
