<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qudi: How to use and create tasks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qudi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to use and create tasks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>General Task Concept</h2>
<p>In order to create a task you can choose between 2 different categories.</p>
<p><b>InterruptableTask</b> or <b>PrePostTask</b></p>
<p>You have to inherit one of those classes (both are situated in <code>/logic/generic_tasks.py</code>) for your tasks and re-implement the class specific methods for your needs. The tasks basically contain a reference to the object you are aiming to manipulate.</p>
<p><b>InterruptableTask</b> are those, which are used to perform the actual task. According to the name of this class, you should design the task such, that it can be interrupted and stopped at any time.</p>
<p>To manage the behaviour of that, a finite state machine construction is used, which defines all possible states of the InterruptableTask object <b>and</b> all valid state transitions (that is the essence of a state machine!). The Graph below shows an ASM (algorithmic state machine) chart of our underlying state machine:</p>
<p>[Graph InterruptableTask here]</p>
<p><b>PrePostTask</b> are those which are done before or follow after the actual InterruptableTask. The state machine description of those tasks are quite simple, as it can be seen in the Graph below.</p>
<p>[Graph PrePostTask here]</p>
<p>In general, the PrePostTasks are quite small steps (like e.g. tilting the mirror, switching on or off of a device for the actual measurement).</p>
<h2>Task Implementation Concept</h2>
<p>So now you have two possibilities to perform a manipulation.</p>
<ol type="1">
<li>Either the task itself just calls a method in the specific object and . then the object itself is responsible how the task will run,..</li>
<li>or you change and control every input/output value and construct (not only limited to one object) your desired task method.</li>
</ol>
<p>For really basic and small tasks (which cannot or are not needed to be separated into smaller tasks) the smartest way to implement task is via one method, which can be called from one object. That idea is only restricted to the scenario, if your task actions are limited to one object only! This very method will handle then all needed changes within the object and will perform the desired task. That idea will facilitate maintainability of the task, since it only depends on the internal implementation of the addressed method. That makes it traceable for the user.</p>
<p>As soon as your task will interact with many object (i.e. retrieve and pass values from one object to the other and react on the obtained parameter) then all the task implementation and object access will be done within the task and not within the other objects, which the task is intended to control.</p>
<p>Think about an obvious/general way of how to return the data after a method, i.e. the structure of the return value, maybe not just a bunch of elements in a list, where you do not know, which element of a list is representing what. Think of using pythons dictionaries, since you can assign to a generic and understandable name to return values. Then you only have to fix yourself on a proper keywords which you will use in the dict.</p>
<p>If the way you are calling and controlling this object is general, then other people will potentially use it.</p>
<h2>Where are tasks saved?</h2>
<p>Custom tasks are logic operations, and therefore saved in the folder <code>/logic/tasks</code> folder. There you can also get an idea how implementation of possible tasks can look like.</p>
<h2>How to add your personal tasks in the config</h2>
<p>Within a configuration file, a custom task configuration may look like that: </p><pre class="fragment">tasklogic:
    module.Class: 'taskrunner.TaskRunner'
    tasks:
        dummytask:
            module: 'dummy'
            preposttasks: ['ppdummy']

        dummyinterruptor:
            module: 'dummy'
            pausetasks: ['dummytask']
            preposttasks: ['ppdummy2']

        ppdummy:
            module: 'prepostdummy'

        ppdummy2:
            module: 'prepostdummy'

        scannerLocationRefocus:
            module: 'refocus'
            preposttasks: ['fliplasermirror']
            pausetasks: ['scan', 'odmr']
            needsmodules:
                optimizer: 'optimizerlogic'
            config:
                initial: [1, 1, 1]

        fliplasermirror:
            module: 'flipmirror'
            needsmodules:
                switchlogic: 'switch'
            config:
                sequence: [('mydummyswitch1', 1, True), ('mydummyswitch1', 2, True), ('mydummyswitch2', 1, True)]
</pre><p>Your individual tasks can be defined below the <code>tasks</code> keyword. The naming procedure is pretty similar to the working principle of our configuration files (<a class="el" href="config-explanation.html">=&gt; How to use a configuration file</a>. </p><pre class="fragment">&lt;identifier1&gt;:
    module: '&lt;module_name1&gt;'
    preposttasks: ['&lt;identifier2&gt;']

&lt;identifier2&gt;:
    module: '&lt;module_name2&gt;'
</pre><p>You choose a name <code>&lt;identifier1&gt;</code>, how the task should be called, and define with the keyword <code>module</code> which task module you want to take. This module (a python file) with name <code>&lt;module_name1&gt;</code> must be present in the  directory.</p>
<h3>Example for an InterruptableTask:</h3>
<p>Within the file <code>&lt;module_name1&gt;.py</code> a class must exist with the name <code>Task</code>, which inherits either the InterruptableTask or PrePostTask class. An example may look like that: </p><pre class="fragment">from logic.generic_task import InterruptableTask

class Task(InterruptableTask):

    def __init__(self, name, runner, references, config):
        """ A task has the following constructor:

        @param str name: unique task name
        @param object runner: reference to the TaskRunner managing this task
        @param dict references: a dictionary of all required modules
        @param dict config: configuration dictionary
        """

        super().__init__(name, runner, references, config)
        print('Task {} added!'.format(self.name))
        print(self.config)

    def startTask(self)
        # Reimplement that!
        return

    def runTaskStep(self)
        # Reimplement that!
        return

    def pauseTask(self)
        # Reimplement that!
        return

    def resumeTask(self)
        # Reimplement that!
        return

    def cleanupTask(self)
        # Reimplement that!
        return
</pre><p>This example above must reimplement each method of the class InterruptableTask. That would be right now the methods:</p>
<ul>
<li>startTask,</li>
<li>runTaskStep,</li>
<li>pauseTask,</li>
<li>resumeTask,</li>
<li>cleanupTask.</li>
</ul>
<p>The additional methods</p><ul>
<li>checkExtraStartPrerequisites,</li>
<li>checkExtraPausePrerequisites</li>
</ul>
<p><b>can</b> be, but have not to be reimplemented, if no special requirements are going to be set for that task. These methods are used to check, whether the present task can be paused if it is in the running state.</p>
<p>Therefore, these methods provides you with e.g. an external checking procedure, which you can implement for the specific task. Consequently the <b>return value</b> has to be of <b>boolean</b> type, i.e. either <code>True</code> or <code>False</code>.</p>
<h3>Example of PrePostTask</h3>
<p>The PrePostTask implementation is much simpler. An example of <code>&lt;module_name2&gt;</code> might look like that: </p><pre class="fragment">from logic.generic_task import PrePostTask

class Task(PrePostTask):

    def __init__(self, name, runner, references, config):
        """ A task has the following constructor:

        @param str name: unique task name
        @param object runner: reference to the TaskRunner managing this task
        @param dict references: a dictionary of all required modules
        @param dict config: configuration dictionary
        """

        super().__init__(name, runner, references, config)
        print('PrePost init task {}'.format(name))
        print(self.config)

    def preExecute(self):
        # Reimplement that!
        return

    def postExecute(self):
        # Reimplement that!
        return
</pre><h3>The reference within a Task Class</h3>
<h3>The config within a</h3>
<h2>Example for the Confocal Optimizer Task</h2>
<h2>Where are the task run?</h2>
<p>All the tasks are handled by the Logic Module TaskRunner.py.</p>
<h2>How to use tasks in other logic</h2>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
