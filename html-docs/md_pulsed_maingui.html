<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Qudi: Structure of Pulsed Main GUI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Qudi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Structure of Pulsed Main GUI </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>General File structure</h2>
<p>Each Tab of the PulsedMainGui is configured in a spatially separated part within the file pulsed_maingui.py. The different parts are declare with such a comment heading structure (here exemplarily shown for the Settings for the 'Pulse Generator' Tab ): </p>
<pre class="fragment">###########################################################################
###     Methods related to Settings for the 'Pulse Generator' Tab:      ###
###########################################################################
</pre><p>The interaction to other file parts will be hold to a minimum. Therefore all methods defined below such a header should as far as possible to interaction with other methods, which are not related to this tab.</p>
<p>Somethings it is not possible to keep the interaction separate, because an establishment of interaction is actually desired. For Maintainability reasons, these interactions will be still kept to an minimum.</p>
<h2>Idea of Pulsed Main GUI interaction with PulsedMeasurementLogic and SequenceGeneratorLogic</h2>
<p>make access via get and set functions.</p>
<h2>Explanation of specific Methods and general concept of object usage</h2>
<h3>Usage of QTableWidgets</h3>
<p>In general a table consist out of an object for viewing the data and of an object where the data are saved. For viewing the data, there is the general QWidgetView class and for holding/storing the data you have to define a model.</p>
<p>The model ensures to hold your data in the proper data type and give the possibility to separate the data from the display. The QTableWidget class is a specialized class to handle user input into an table. In order to handle the data, it contains already a model (due to that you can e.g. easily add rows and columns and modify the content of each cell). Therefore the model of a QTableWidget is a private attribute and cannot be changed externally. If you want to define a custom model for QTableWidget you have to start from a QTableView and construct your own data handling in the model.</p>
<p>Since QTableWidget has all the (nice and) needed requirements for us, a custom definition of QTableView with a Model is not needed.</p>
<h3>Customize Delegate Methods for QTableWidget</h3>
<p>The delegation is a procedure, where you a new or another constructor and viewer will be assigned to QWidget objects.</p>
<p>Here the constructor and viewer for entries in a QTableWidget will be altered by using customized Delegation.</p>
<p>A general idea, which functions are customizable for our purpose is displayed in the documentation for the <a href="http://pyqt.sourceforge.net/Docs/PyQt4/qitemdelegate.html" title="QItemDelegate Class Reference">QItemDelegate Class</a>, which is worth reading!</p>
<p>If you want to delegate a row or a column of a QTableWidget, then you have at least to declare the constructors and the modification function for the displayed data (which you see in the table) and the saved data (which is handeled by the model class of the table). That means your delegate should at least contain the functions:</p>
<ul>
<li>createEditor</li>
<li>setEditor</li>
<li>updateEditorGeometry</li>
<li>setModelData</li>
</ul>
<p>I.e. when editing data in an item view, editors are created and displayed by a delegate.</p>
<p>Use the <a href="http://pyqt.sourceforge.net/Docs/PyQt4/qstyleditemdelegate.html" title="QStyledItemDelegate Class Reference">QStyledItemDelegate class</a>, instead of <a href="http://pyqt.sourceforge.net/Docs/PyQt4/qitemdelegate.html" title="QItemDelegate Class Reference">QItemDelegate class</a>, since the first one provides extended possibilities of painting the windows and can be changed by Qt style sheets.</p>
<p>Since the delegate is a subclass of QItemDelegate or QStyledItemDelegate, the data it retrieves from the model and is displayed in a default style, and we do not need to provide a custom paintEvent(). We use QStyledItemDelegate as our base class, so that we benefit from the default delegate implementation. We could also have used <a href="http://pyqt.sourceforge.net/Docs/PyQt4/qabstractitemdelegate.html" title="QAbstractItemDelegate Class Reference">QAbstractItemDelegate class</a>, if we had wanted to start completely from scratch.</p>
<p>Examples how to create e.g. of SpinBoxdelegate in native Qt: <a href="http://qt.developpez.com/doc/4.7/itemviews-spinboxdelegate/">http://qt.developpez.com/doc/4.7/itemviews-spinboxdelegate/</a> and a similar python implementation: <a href="https://github.com/PySide/Examples/blob/master/examples/itemviews/spinboxdelegate.py">https://github.com/PySide/Examples/blob/master/examples/itemviews/spinboxdelegate.py</a></p>
<h3>How are the mathematical functions displayed in the Block Editor</h3>
<p>Relate that to the method get_func_config from the sequence generator logic</p>
<h3>How are the table widgets being created, configured and arranged</h3>
<p>The columns for the Table Widgets are determined by the present <code>channel_config</code> obtained from the hardware constraints and the <code>add_pbe_param</code> ( = additional Pulse_Block_Element Parameter) and <code>add_pb_param</code> ( = additional Pulse_Block Parameters) dictionary in the logic.</p>
<p>How the configuration is eventually arranged in the GUI in the QTableWidgets will be told in the dictionary <code>cfg_param_pbe</code> ( = configuration Parameter for Pulse_Block_Element objects) and <code>cfg_param_pb</code> ( = configuration Parameter for Pulse_Block objects). These dictionaries are written from the GUI to the Logic in order to have a standardized way for obtaining and saving the display configuration.</p>
<p><b>These set of dictionaries will and should handle all needed information. Moreover it is a way to centralize the configuration to a small set of configuration dictionaries and avoid the establishment of various obscure cross relationship between Logic and GUI variables!</b></p>
<p><code>cfg_param_pbe</code> and <code>cfg_param_pb</code> are abstract dictionary, which tells the logic the configuration of a Pulse_Block_Element, i.e. how many parameters are used for a Pulse_Block_Element (pbe) object (in the GUI). In principle, the way how the GUI is displaying the pbe object should be irrelevant for the logic (which is guaranteed by these abstract dictionaries)!</p>
<p>Parameters to create all needed rows for analog channels are taken from the <code>get_func_config</code> method from the Logic, where the biggest desired function will be taken for the input of the analog parameters. The biggest function can be changed in the Settings of the Block Generation.</p>
<h3>Influence of Channel_config and activation_map on the GUI</h3>
<p>The GUI asks for the hardware constraints in order to obtain all parameters in <code>channel_config</code>. The available channel configuration will determine the display for the Pulse Block Editor.</p>
<p>By pressing the <code>Pulser On</code> or <code>Pulser Off</code> button, or starting the Pulse Experiment with the Start Button in the ToolBar, the <code>pulser_on_clicked</code> or <code>pulser_on_clicked</code> method will pass those channel to the Logic, which should be activated or deactivated, according to the selected activation map.</p>
<p>The activation map can also be chosen in the Settings of Block Generation (which is basically dictated by the hardware). The hardware will state all possible activation and deactivation scenarios for the corresponding channels. Note, that the <code>activation_map</code> parameter is <b>substantially different</b> from the <code>channel_config</code> parameter (both parameters can be found in the dictionary which the GUI obtains from the Logic, by asking for the hardware constraints).</p>
<p>The activation map is the additional information, you will need for several pulsing devices. See more information about these parameters in the explanation of the Pulser Interface. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
