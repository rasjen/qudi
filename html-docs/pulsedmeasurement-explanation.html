<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qudi: How to run a pulsed measurement</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qudi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to run a pulsed measurement </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="pulsed_structure.png" alt="Structural overview of pulsed measurement modules" title="Pulsed structure"/>
</div>
<p>To understand the logic modules (mainly sequence_generator_logic and pulsed_measurement_logic), this documentation will provide a step-by-step manual for scripting a pulsed measurement. This can also be used to properly implement a GUI which sets all variables and calls the right methods in the logic.</p>
<p>In general, the two logic modules for measurement and sequence generation are independent from each other. Currently, the sequence_generation_logic is interfacing to the pulser hardware to check for parameters and upload waveforms. In the future, this needs to be fixed so that the sequence generation runs independent of the hardware (for example you can simply set a sample rate which the waveform should be created for independent of the actual sample rate on hardware). Also the upload and load to channels need to be implemented in the pulsed_measurement_logic rather than the sequence_generation_logic.</p>
<p>But let's see the steps towards a pulsed measurement:</p>
<h2>Step 1: Prepare sequence_generator_logic/pulser hardware for pulse sequence generation</h2>
<p>Needs to be implemented so that all parameters for the sampling of the waveform can be set in the logic independent of hardware itself. In the meantime you need to set up the AWG settings for your measurement:</p>
<ul>
<li>Activate/Deactivate desired channels on hardware <pre class="fragment">  ch = {'a_ch1': True, 'd_ch1': True, 'd_ch2': False}
  pulser.set_active_channels(ch)
</pre></li>
<li>Set sample rate <pre class="fragment">  sample_rate = 25e9 (for 25 GSample/s)
  actual_sample_rate = pulser.set_sample_rate(sample_rate)
</pre></li>
<li>Set the sample mode for the waveform creation (look this up in the hadrware module for your device) <pre class="fragment">  pulser.current_sample_mode = pulser.sample_mode['wfmx-file']
</pre></li>
</ul>
<h2>Step 2: Create abstract pulse sequence data object and sample it to create waveform file</h2>
<p>First of all you need to get the classes for the abstract data objects for your script: </p><pre class="fragment">from logic.sequence_generator_logic import Pulse_Block_Element, Pulse_Block, Pulse_Block_Ensemble
</pre><ul>
<li>generate a Pulse_Block_Ensemble object out of Pulse_Block_Element and Pulse_Block objects (check <em>init</em> methods for each object)</li>
<li>save/serialize the objects to file <pre class="fragment">  sequencegenerator.save_block('block_name_1', block_object_instance_1)
  sequencegenerator.save_block('block_name_2', block_object_instance_2)
  sequencegenerator.save_ensemble('ensemble_name', ensemble_object_instance)
</pre></li>
<li>Create hardware waveform file ("chunkwise" is used to save memory but slows down the process a great deal if enabled) <pre class="fragment">  sequencegenerator.sample_pulse_block_ensemble('ensemble_name', write_to_file=True, chunkwise=True|False)
</pre></li>
</ul>
<h2>Step 3: Upload waveform to pulser device and load into channels</h2>
<p>This functionality should be in the pulsed_measurement_logic in the future. For now we call the hardware methods directly</p>
<ul>
<li>Upload created waveform to the pulser hardware HDD <pre class="fragment">  pulser.upload_asset('ensemble_name')
</pre></li>
<li>Load created waveform into pulser channels <pre class="fragment">  pulser.load_asset('ensemble_name')
</pre></li>
</ul>
<h2>Step 4: Configure pulsed_measurement_logic parameters to prepare the measurement</h2>
<ul>
<li>Set the approximate over-estimated delay in seconds between laser trigger signal and actual laser output <pre class="fragment">  pulsedmeasurement.aom_delay_s = 700e-9 (700 ns)
</pre></li>
<li>Set the length of the laser pulses in seconds <pre class="fragment">  pulsedmeasurement.laser_length_s = 3e-6 (3000 ns)
</pre></li>
<li>Set the total number of laser pulses within the created waveform <pre class="fragment">  pulsedmeasurement.set_num_of_lasers(50) (50 laser pulses in the sequence)
</pre></li>
<li>Set the fast counter binwidth in seconds <pre class="fragment">  pulsedmeasurement.set_fc_binning(1e-9) (1 ns)
</pre></li>
<li>Set starting index of timebin for the signal analysis window <pre class="fragment">  pulsedmeasurement.signal_start_bin = 5 (in our case 5 ns after rising flank)
</pre></li>
<li>Set index width of timebins for the signal analysis window <pre class="fragment">  pulsedmeasurement.signal_width_bin = 200 (200 ns signal window width)
</pre></li>
<li>Set starting index of timebin for the normalization analysis window <pre class="fragment">  pulsedmeasurement.norm_start_bin = 1500 (in our case 1500 ns after rising flank)
</pre></li>
<li>Set index width of timebins for the normalization analysis window <pre class="fragment">  pulsedmeasurement.norm_width_bin = 1000 (1000 ns signal window width)
</pre></li>
<li>Set the independent axis data point values as array <pre class="fragment">  pulsedmeasurement.set_measurement_ticks_list(numpy.arange(1,50,1)) (this will result in an x-axis showing only laser pulse indices 0..49)
</pre></li>
<li>Set the analysis time intervall for the running measurement in seconds <pre class="fragment">  pulsedmeasurement.set_timer_interval(3) (refresh measurement data every 3 seconds)
</pre></li>
</ul>
<h2>Step 5: Configure fast counter hardware</h2>
<pre class="fragment">pulsedmeasurement.configure_fast_counter()
</pre><h2>Step 6: Perform measurement</h2>
<ul>
<li>Start the measurement <pre class="fragment">  pulsedmeasurement.start_pulsed_measurement()
</pre></li>
<li>Wait for how long you want to measure</li>
<li>Stop the measurement <pre class="fragment">  pulsedmeasurement.stop_pulsed_measurement()
</pre></li>
<li>Save data <pre class="fragment">  pulsedmeasurement._save_data(tag = 'measurement_name')
</pre></li>
<li>Maybe you want to fit your data <pre class="fragment">  fit_x, fit_y, fit_result = pulsedmeasurement.do_fit('Sine') (performs a Sine fit on the current measurement data)
</pre></li>
<li>direct access to measurement data via <pre class="fragment">  pulsedmeasurement.signal_plot_x (independent variable of measurement)
  pulsedmeasurement.signal_plot_y (evaluated measurement points)
  pulsedmeasurement.laser_data (extracted laser pulses)
  pulsedmeasurement.raw_data (raw fast counter data)
</pre></li>
</ul>
<h2>Example IPython notebook for pulsed ODMR and Rabi measurements (not perfect, just a working thing...)</h2>
<div class="image">
<img src="../notebooks/generate_pulsedodmr.ipynb" alt="IPython notebook example"/>
</div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
