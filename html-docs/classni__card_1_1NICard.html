<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Qudi: ni_card.NICard Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qudi
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ni_card</b></li><li class="navelem"><a class="el" href="classni__card_1_1NICard.html">NICard</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classni__card_1_1NICard-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ni_card.NICard Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>stable Kay Jahnke, Alexander Stark  
 <a href="classni__card_1_1NICard.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ni_card.NICard:</div>
<div class="dyncontent">
<div class="center"><img src="classni__card_1_1NICard__inherit__graph.png" border="0" usemap="#ni__card_8NICard_inherit__map" alt="Inheritance graph"/></div>
<map name="ni__card_8NICard_inherit__map" id="ni__card_8NICard_inherit__map">
<area shape="rect" id="node15" href="classni__card_1_1SlowGatedNICard.html" title="Enable the usage of the gated counter in the slow counter interface. " alt="" coords="272,237,445,267"/>
<area shape="rect" id="node2" href="classcore_1_1base_1_1Base.html" title="Base class for all loadable modules. " alt="" coords="57,83,169,112"/>
<area shape="rect" id="node6" href="classcore_1_1FysomAdapter_1_1Fysom.html" title="core.FysomAdapter.Fysom" alt="" coords="99,5,277,35"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ni_card.NICard:</div>
<div class="dyncontent">
<div class="center"><img src="classni__card_1_1NICard__coll__graph.png" border="0" usemap="#ni__card_8NICard_coll__map" alt="Collaboration graph"/></div>
<map name="ni__card_8NICard_coll__map" id="ni__card_8NICard_coll__map">
<area shape="rect" id="node2" href="classcore_1_1base_1_1Base.html" title="Base class for all loadable modules. " alt="" coords="57,83,169,112"/>
<area shape="rect" id="node6" href="classcore_1_1FysomAdapter_1_1Fysom.html" title="core.FysomAdapter.Fysom" alt="" coords="99,5,277,35"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c977276c23510dda2aeff3d3a9432bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a1c977276c23510dda2aeff3d3a9432bf">on_activate</a> (self, e=None)</td></tr>
<tr class="memdesc:a1c977276c23510dda2aeff3d3a9432bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts up the NI Card at activation.  <a href="#a1c977276c23510dda2aeff3d3a9432bf">More...</a><br /></td></tr>
<tr class="separator:a1c977276c23510dda2aeff3d3a9432bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711d4ab0dff688ccbc343d292a68a4af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a711d4ab0dff688ccbc343d292a68a4af">on_deactivate</a> (self, e=None)</td></tr>
<tr class="memdesc:a711d4ab0dff688ccbc343d292a68a4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down the NI card.  <a href="#a711d4ab0dff688ccbc343d292a68a4af">More...</a><br /></td></tr>
<tr class="separator:a711d4ab0dff688ccbc343d292a68a4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94351394f0e7a270787bc8fdc304eb6e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a94351394f0e7a270787bc8fdc304eb6e">get_constraints</a> (self)</td></tr>
<tr class="memdesc:a94351394f0e7a270787bc8fdc304eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hardware limits of NI device.  <a href="#a94351394f0e7a270787bc8fdc304eb6e">More...</a><br /></td></tr>
<tr class="separator:a94351394f0e7a270787bc8fdc304eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e1697039257ef32c6324bd958942c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#aa4e1697039257ef32c6324bd958942c0">set_up_clock</a> (self, clock_frequency=None, clock_channel=None, scanner=False, idle=False)</td></tr>
<tr class="memdesc:aa4e1697039257ef32c6324bd958942c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the hardware clock of the NiDAQ card to give the timing.  <a href="#aa4e1697039257ef32c6324bd958942c0">More...</a><br /></td></tr>
<tr class="separator:aa4e1697039257ef32c6324bd958942c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fc37611b383c9229731c689acb2ea6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ac3fc37611b383c9229731c689acb2ea6">set_up_counter</a> (self, counter_channels=None, sources=None, clock_channel=None, counter_buffer=None)</td></tr>
<tr class="memdesc:ac3fc37611b383c9229731c689acb2ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the actual counter with a given clock.  <a href="#ac3fc37611b383c9229731c689acb2ea6">More...</a><br /></td></tr>
<tr class="separator:ac3fc37611b383c9229731c689acb2ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f349fb7f6461c49bef0cf251371768a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a8f349fb7f6461c49bef0cf251371768a">get_counter_channels</a> (self)</td></tr>
<tr class="memdesc:a8f349fb7f6461c49bef0cf251371768a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of counter channel names.  <a href="#a8f349fb7f6461c49bef0cf251371768a">More...</a><br /></td></tr>
<tr class="separator:a8f349fb7f6461c49bef0cf251371768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6789bd4425a4acb2c625df91a319dc11"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a6789bd4425a4acb2c625df91a319dc11">get_counter</a> (self, samples=None)</td></tr>
<tr class="memdesc:a6789bd4425a4acb2c625df91a319dc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current counts per second of the counter.  <a href="#a6789bd4425a4acb2c625df91a319dc11">More...</a><br /></td></tr>
<tr class="separator:a6789bd4425a4acb2c625df91a319dc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7489c1f4e1516f04c319d39247f507c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a7489c1f4e1516f04c319d39247f507c1">close_counter</a> (self, scanner=False)</td></tr>
<tr class="memdesc:a7489c1f4e1516f04c319d39247f507c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the counter or scanner and cleans up afterwards.  <a href="#a7489c1f4e1516f04c319d39247f507c1">More...</a><br /></td></tr>
<tr class="separator:a7489c1f4e1516f04c319d39247f507c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fbd314b886f771c0d58e6746a7bc48"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a30fbd314b886f771c0d58e6746a7bc48">close_clock</a> (self, scanner=False)</td></tr>
<tr class="memdesc:a30fbd314b886f771c0d58e6746a7bc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the clock and cleans up afterwards.  <a href="#a30fbd314b886f771c0d58e6746a7bc48">More...</a><br /></td></tr>
<tr class="separator:a30fbd314b886f771c0d58e6746a7bc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad424a77445bdea11026484c137ad89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a3ad424a77445bdea11026484c137ad89">reset_hardware</a> (self)</td></tr>
<tr class="memdesc:a3ad424a77445bdea11026484c137ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the NI hardware, so the connection is lost and other programs can access it.  <a href="#a3ad424a77445bdea11026484c137ad89">More...</a><br /></td></tr>
<tr class="separator:a3ad424a77445bdea11026484c137ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96472c58e0419946575aa379165d7e6"><td class="memItemLeft" align="right" valign="top"><a id="ad96472c58e0419946575aa379165d7e6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ad96472c58e0419946575aa379165d7e6">get_scanner_axes</a> (self)</td></tr>
<tr class="memdesc:ad96472c58e0419946575aa379165d7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scanner axes depends on how many channels tha analog output task has. <br /></td></tr>
<tr class="separator:ad96472c58e0419946575aa379165d7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be8446ab426bc5645dd55416c5f14d9"><td class="memItemLeft" align="right" valign="top"><a id="a0be8446ab426bc5645dd55416c5f14d9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a0be8446ab426bc5645dd55416c5f14d9">get_scanner_count_channels</a> (self)</td></tr>
<tr class="memdesc:a0be8446ab426bc5645dd55416c5f14d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of counter channels. <br /></td></tr>
<tr class="separator:a0be8446ab426bc5645dd55416c5f14d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5267dc97a7819a87e23395d626ae683"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#af5267dc97a7819a87e23395d626ae683">get_position_range</a> (self)</td></tr>
<tr class="memdesc:af5267dc97a7819a87e23395d626ae683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the physical range of the scanner.  <a href="#af5267dc97a7819a87e23395d626ae683">More...</a><br /></td></tr>
<tr class="separator:af5267dc97a7819a87e23395d626ae683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526922b67a75bb1a023a28b8b0dc3e2a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a526922b67a75bb1a023a28b8b0dc3e2a">set_position_range</a> (self, myrange=None)</td></tr>
<tr class="memdesc:a526922b67a75bb1a023a28b8b0dc3e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the physical range of the scanner.  <a href="#a526922b67a75bb1a023a28b8b0dc3e2a">More...</a><br /></td></tr>
<tr class="separator:a526922b67a75bb1a023a28b8b0dc3e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f1ffa246fac47565b6624b489ca0ba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a86f1ffa246fac47565b6624b489ca0ba">set_voltage_range</a> (self, myrange=None)</td></tr>
<tr class="memdesc:a86f1ffa246fac47565b6624b489ca0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the voltage range of the NI Card.  <a href="#a86f1ffa246fac47565b6624b489ca0ba">More...</a><br /></td></tr>
<tr class="separator:a86f1ffa246fac47565b6624b489ca0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad588ef812b7f227eba9a356d1bd97ef6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ad588ef812b7f227eba9a356d1bd97ef6">set_up_scanner_clock</a> (self, clock_frequency=None, clock_channel=None)</td></tr>
<tr class="memdesc:ad588ef812b7f227eba9a356d1bd97ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the hardware clock of the NiDAQ card to give the timing.  <a href="#ad588ef812b7f227eba9a356d1bd97ef6">More...</a><br /></td></tr>
<tr class="separator:ad588ef812b7f227eba9a356d1bd97ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816cadbc91ebe56757c85ec07fd44c1c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a816cadbc91ebe56757c85ec07fd44c1c">set_up_scanner</a> (self, counter_channels=None, sources=None, clock_channel=None, scanner_ao_channels=None)</td></tr>
<tr class="memdesc:a816cadbc91ebe56757c85ec07fd44c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the actual scanner with a given clock.  <a href="#a816cadbc91ebe56757c85ec07fd44c1c">More...</a><br /></td></tr>
<tr class="separator:a816cadbc91ebe56757c85ec07fd44c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f68689c37ed37d9a1499720030c87d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a4f68689c37ed37d9a1499720030c87d8">scanner_set_position</a> (self, x=None, y=None, z=None, a=None)</td></tr>
<tr class="memdesc:a4f68689c37ed37d9a1499720030c87d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move stage to x, y, z, a (where a is the fourth voltage channel).  <a href="#a4f68689c37ed37d9a1499720030c87d8">More...</a><br /></td></tr>
<tr class="separator:a4f68689c37ed37d9a1499720030c87d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e69f8e8b6f8131b8faf37f77408d5b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a75e69f8e8b6f8131b8faf37f77408d5b">get_scanner_position</a> (self)</td></tr>
<tr class="memdesc:a75e69f8e8b6f8131b8faf37f77408d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current position of the scanner hardware.  <a href="#a75e69f8e8b6f8131b8faf37f77408d5b">More...</a><br /></td></tr>
<tr class="separator:a75e69f8e8b6f8131b8faf37f77408d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0358c76eabd9006917705f7dd117d8de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a0358c76eabd9006917705f7dd117d8de">set_up_line</a> (self, length=100)</td></tr>
<tr class="memdesc:a0358c76eabd9006917705f7dd117d8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the analog output for scanning a line.  <a href="#a0358c76eabd9006917705f7dd117d8de">More...</a><br /></td></tr>
<tr class="separator:a0358c76eabd9006917705f7dd117d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a215848497ac630fd2ce74f344f3c2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a50a215848497ac630fd2ce74f344f3c2">scan_line</a> (self, line_path=None)</td></tr>
<tr class="memdesc:a50a215848497ac630fd2ce74f344f3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans a line and return the counts on that line.  <a href="#a50a215848497ac630fd2ce74f344f3c2">More...</a><br /></td></tr>
<tr class="separator:a50a215848497ac630fd2ce74f344f3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe2b8405fd455020ed0da8ace0980f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#adbe2b8405fd455020ed0da8ace0980f7">close_scanner</a> (self)</td></tr>
<tr class="memdesc:adbe2b8405fd455020ed0da8ace0980f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the scanner and cleans up afterwards.  <a href="#adbe2b8405fd455020ed0da8ace0980f7">More...</a><br /></td></tr>
<tr class="separator:adbe2b8405fd455020ed0da8ace0980f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a964bbf1d3f2ddd6726f0cd85ab0fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a52a964bbf1d3f2ddd6726f0cd85ab0fb">close_scanner_clock</a> (self)</td></tr>
<tr class="memdesc:a52a964bbf1d3f2ddd6726f0cd85ab0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the clock and cleans up afterwards.  <a href="#a52a964bbf1d3f2ddd6726f0cd85ab0fb">More...</a><br /></td></tr>
<tr class="separator:a52a964bbf1d3f2ddd6726f0cd85ab0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f12330aa92f2c7e4e0a3c95e702764"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a39f12330aa92f2c7e4e0a3c95e702764">set_up_odmr_clock</a> (self, clock_frequency=None, clock_channel=None)</td></tr>
<tr class="memdesc:a39f12330aa92f2c7e4e0a3c95e702764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the hardware clock of the NiDAQ card to give the timing.  <a href="#a39f12330aa92f2c7e4e0a3c95e702764">More...</a><br /></td></tr>
<tr class="separator:a39f12330aa92f2c7e4e0a3c95e702764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e1375b5aed38672390ca6ea36b63d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ab0e1375b5aed38672390ca6ea36b63d8">set_up_odmr</a> (self, counter_channel=None, photon_source=None, clock_channel=None, odmr_trigger_channel=None)</td></tr>
<tr class="memdesc:ab0e1375b5aed38672390ca6ea36b63d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the actual counter with a given clock.  <a href="#ab0e1375b5aed38672390ca6ea36b63d8">More...</a><br /></td></tr>
<tr class="separator:ab0e1375b5aed38672390ca6ea36b63d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ea0874c5f480cbae928ad067844bf5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a31ea0874c5f480cbae928ad067844bf5">set_odmr_length</a> (self, length=100)</td></tr>
<tr class="memdesc:a31ea0874c5f480cbae928ad067844bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the trigger sequence for the ODMR and the triggered microwave.  <a href="#a31ea0874c5f480cbae928ad067844bf5">More...</a><br /></td></tr>
<tr class="separator:a31ea0874c5f480cbae928ad067844bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3389d0ffc952031893cd55e52d110a97"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a3389d0ffc952031893cd55e52d110a97">count_odmr</a> (self, length=100)</td></tr>
<tr class="memdesc:a3389d0ffc952031893cd55e52d110a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sweeps the microwave and returns the counts on that sweep.  <a href="#a3389d0ffc952031893cd55e52d110a97">More...</a><br /></td></tr>
<tr class="separator:a3389d0ffc952031893cd55e52d110a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6765f3ec111dcc765cdac26cf1bf79b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#af6765f3ec111dcc765cdac26cf1bf79b">close_odmr</a> (self)</td></tr>
<tr class="memdesc:af6765f3ec111dcc765cdac26cf1bf79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the odmr and cleans up afterwards.  <a href="#af6765f3ec111dcc765cdac26cf1bf79b">More...</a><br /></td></tr>
<tr class="separator:af6765f3ec111dcc765cdac26cf1bf79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5530f85f593dc7ac6ade6b8f65daf08e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a5530f85f593dc7ac6ade6b8f65daf08e">close_odmr_clock</a> (self)</td></tr>
<tr class="memdesc:a5530f85f593dc7ac6ade6b8f65daf08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the odmr and cleans up afterwards.  <a href="#a5530f85f593dc7ac6ade6b8f65daf08e">More...</a><br /></td></tr>
<tr class="separator:a5530f85f593dc7ac6ade6b8f65daf08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313f64947f81d58fbc86691a78a54162"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a313f64947f81d58fbc86691a78a54162">get_status</a> (self)</td></tr>
<tr class="memdesc:a313f64947f81d58fbc86691a78a54162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the current status of the Fast Counter and outputs it as return value.  <a href="#a313f64947f81d58fbc86691a78a54162">More...</a><br /></td></tr>
<tr class="separator:a313f64947f81d58fbc86691a78a54162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad621cb56e4adc8997deba3908eb785e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ad621cb56e4adc8997deba3908eb785e2">set_up_gated_counter</a> (self, buffer_length, read_available_samples=False)</td></tr>
<tr class="memdesc:ad621cb56e4adc8997deba3908eb785e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and starts task for external gated photon counting.  <a href="#ad621cb56e4adc8997deba3908eb785e2">More...</a><br /></td></tr>
<tr class="separator:ad621cb56e4adc8997deba3908eb785e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcfaa68c2c22e133b7e88eec6aaef81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#abdcfaa68c2c22e133b7e88eec6aaef81">start_gated_counter</a> (self)</td></tr>
<tr class="memdesc:abdcfaa68c2c22e133b7e88eec6aaef81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually start the preconfigured counter task.  <a href="#abdcfaa68c2c22e133b7e88eec6aaef81">More...</a><br /></td></tr>
<tr class="separator:abdcfaa68c2c22e133b7e88eec6aaef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412e89ef7d0a305937c31eaf5f0924d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#a412e89ef7d0a305937c31eaf5f0924d2">get_gated_counts</a> (self, samples=None, timeout=None, read_available_samples=False)</td></tr>
<tr class="memdesc:a412e89ef7d0a305937c31eaf5f0924d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns latest count samples acquired by gated photon counting.  <a href="#a412e89ef7d0a305937c31eaf5f0924d2">More...</a><br /></td></tr>
<tr class="separator:a412e89ef7d0a305937c31eaf5f0924d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad020dd3cb95dd98cb2524f2f4369ba73"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#ad020dd3cb95dd98cb2524f2f4369ba73">stop_gated_counter</a> (self)</td></tr>
<tr class="memdesc:ad020dd3cb95dd98cb2524f2f4369ba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually start the preconfigured counter task.  <a href="#ad020dd3cb95dd98cb2524f2f4369ba73">More...</a><br /></td></tr>
<tr class="separator:ad020dd3cb95dd98cb2524f2f4369ba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8ac2d05ff4c01cdd024a67d14cccdb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classni__card_1_1NICard.html#aec8ac2d05ff4c01cdd024a67d14cccdb">close_gated_counter</a> (self)</td></tr>
<tr class="memdesc:aec8ac2d05ff4c01cdd024a67d14cccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear tasks, so that counters are not in use any more.  <a href="#aec8ac2d05ff4c01cdd024a67d14cccdb">More...</a><br /></td></tr>
<tr class="separator:aec8ac2d05ff4c01cdd024a67d14cccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcore_1_1base_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcore_1_1base_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcore_1_1base_1_1Base.html">core.base.Base</a></td></tr>
<tr class="memitem:a00eaa414a0f7adbb07cd80332dc93f07 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a00eaa414a0f7adbb07cd80332dc93f07">__init__</a> (self, manager, name, config=None, callbacks=None, kwargs)</td></tr>
<tr class="memdesc:a00eaa414a0f7adbb07cd80332dc93f07 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise <a class="el" href="classcore_1_1base_1_1Base.html" title="Base class for all loadable modules. ">Base</a> class object and set up its state machine.  <a href="classcore_1_1base_1_1Base.html#a00eaa414a0f7adbb07cd80332dc93f07">More...</a><br /></td></tr>
<tr class="separator:a00eaa414a0f7adbb07cd80332dc93f07 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593dead28bf66a4cc1cd28e8262a78f9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a593dead28bf66a4cc1cd28e8262a78f9">__getattr__</a> (self, name)</td></tr>
<tr class="memdesc:a593dead28bf66a4cc1cd28e8262a78f9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute getter.  <a href="classcore_1_1base_1_1Base.html#a593dead28bf66a4cc1cd28e8262a78f9">More...</a><br /></td></tr>
<tr class="separator:a593dead28bf66a4cc1cd28e8262a78f9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8bbc08f81b4fb0b058615a6745a4536 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top"><a id="aa8bbc08f81b4fb0b058615a6745a4536"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#aa8bbc08f81b4fb0b058615a6745a4536">log</a> (self)</td></tr>
<tr class="memdesc:aa8bbc08f81b4fb0b058615a6745a4536 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a logger object. <br /></td></tr>
<tr class="separator:aa8bbc08f81b4fb0b058615a6745a4536 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09de170a25ef2d2e0bff51077325111 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#ab09de170a25ef2d2e0bff51077325111">on_activate</a> (self, e)</td></tr>
<tr class="memdesc:ab09de170a25ef2d2e0bff51077325111 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method called when module is activated.  <a href="classcore_1_1base_1_1Base.html#ab09de170a25ef2d2e0bff51077325111">More...</a><br /></td></tr>
<tr class="separator:ab09de170a25ef2d2e0bff51077325111 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5eaa7c5e91fb4fea887ea2dca72bb9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a7a5eaa7c5e91fb4fea887ea2dca72bb9">on_deactivate</a> (self, e)</td></tr>
<tr class="memdesc:a7a5eaa7c5e91fb4fea887ea2dca72bb9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method called when module is deactivated.  <a href="classcore_1_1base_1_1Base.html#a7a5eaa7c5e91fb4fea887ea2dca72bb9">More...</a><br /></td></tr>
<tr class="separator:a7a5eaa7c5e91fb4fea887ea2dca72bb9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613265c763974dd6cc1781eac6e9d752 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a613265c763974dd6cc1781eac6e9d752">onchangestate</a> (self, e)</td></tr>
<tr class="memdesc:a613265c763974dd6cc1781eac6e9d752 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fysom callback for state transition.  <a href="classcore_1_1base_1_1Base.html#a613265c763974dd6cc1781eac6e9d752">More...</a><br /></td></tr>
<tr class="separator:a613265c763974dd6cc1781eac6e9d752 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68421854bf420e2065fff8fcebc08b5 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#ac68421854bf420e2065fff8fcebc08b5">getStatusVariables</a> (self)</td></tr>
<tr class="memdesc:ac68421854bf420e2065fff8fcebc08b5 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a dict of variable names and their content representing the module state for saving.  <a href="classcore_1_1base_1_1Base.html#ac68421854bf420e2065fff8fcebc08b5">More...</a><br /></td></tr>
<tr class="separator:ac68421854bf420e2065fff8fcebc08b5 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f285820af63ebd7bec05d10734c3ac9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a3f285820af63ebd7bec05d10734c3ac9">setStatusVariables</a> (self, variableDict)</td></tr>
<tr class="memdesc:a3f285820af63ebd7bec05d10734c3ac9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a module a dict of variable names and their content representing the module state.  <a href="classcore_1_1base_1_1Base.html#a3f285820af63ebd7bec05d10734c3ac9">More...</a><br /></td></tr>
<tr class="separator:a3f285820af63ebd7bec05d10734c3ac9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0e0e92232cb1be45a1796d1c0289d9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a2c0e0e92232cb1be45a1796d1c0289d9">getState</a> (self)</td></tr>
<tr class="memdesc:a2c0e0e92232cb1be45a1796d1c0289d9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of the state machine implemented in this class.  <a href="classcore_1_1base_1_1Base.html#a2c0e0e92232cb1be45a1796d1c0289d9">More...</a><br /></td></tr>
<tr class="separator:a2c0e0e92232cb1be45a1796d1c0289d9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a672046de78d3f27ffc610aaa3e94b0 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a2a672046de78d3f27ffc610aaa3e94b0">getConfiguration</a> (self)</td></tr>
<tr class="memdesc:a2a672046de78d3f27ffc610aaa3e94b0 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the configration dictionary for this module.  <a href="classcore_1_1base_1_1Base.html#a2a672046de78d3f27ffc610aaa3e94b0">More...</a><br /></td></tr>
<tr class="separator:a2a672046de78d3f27ffc610aaa3e94b0 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd114ca1eae6937163df8fa64e2214b7 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#abd114ca1eae6937163df8fa64e2214b7">getConfigDirectory</a> (self)</td></tr>
<tr class="memdesc:abd114ca1eae6937163df8fa64e2214b7 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the configuration directory for the manager this module belongs to.  <a href="classcore_1_1base_1_1Base.html#abd114ca1eae6937163df8fa64e2214b7">More...</a><br /></td></tr>
<tr class="separator:abd114ca1eae6937163df8fa64e2214b7 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac916fdd306855cd57a77568ff8d93d4a inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#ac916fdd306855cd57a77568ff8d93d4a">get_main_dir</a> (self)</td></tr>
<tr class="memdesc:ac916fdd306855cd57a77568ff8d93d4a inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolut path to the directory of the main software.  <a href="classcore_1_1base_1_1Base.html#ac916fdd306855cd57a77568ff8d93d4a">More...</a><br /></td></tr>
<tr class="separator:ac916fdd306855cd57a77568ff8d93d4a inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4fc6b6a6391b37a8a9099b44f87ac7 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a2c4fc6b6a6391b37a8a9099b44f87ac7">get_home_dir</a> (self)</td></tr>
<tr class="memdesc:a2c4fc6b6a6391b37a8a9099b44f87ac7 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the path to the home directory, which should definitely exist.  <a href="classcore_1_1base_1_1Base.html#a2c4fc6b6a6391b37a8a9099b44f87ac7">More...</a><br /></td></tr>
<tr class="separator:a2c4fc6b6a6391b37a8a9099b44f87ac7 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc55a7b30c571606d06028d1640883d9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#abc55a7b30c571606d06028d1640883d9">get_in_connector</a> (self, connector_name)</td></tr>
<tr class="memdesc:abc55a7b30c571606d06028d1640883d9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return module connected to the given named connector.  <a href="classcore_1_1base_1_1Base.html#abc55a7b30c571606d06028d1640883d9">More...</a><br /></td></tr>
<tr class="separator:abc55a7b30c571606d06028d1640883d9 inherit pub_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcore_1_1FysomAdapter_1_1Fysom"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcore_1_1FysomAdapter_1_1Fysom')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcore_1_1FysomAdapter_1_1Fysom.html">core.FysomAdapter.Fysom</a></td></tr>
<tr class="memitem:a47106a50e06d152cbd5ee6f5ff4d58c0 inherit pub_methods_classcore_1_1FysomAdapter_1_1Fysom"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1FysomAdapter_1_1Fysom.html#a47106a50e06d152cbd5ee6f5ff4d58c0">__init__</a> (self, cfg=None, initial=None, events=None, callbacks=None, final=None, kwargs)</td></tr>
<tr class="memdesc:a47106a50e06d152cbd5ee6f5ff4d58c0 inherit pub_methods_classcore_1_1FysomAdapter_1_1Fysom"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classcore_1_1FysomAdapter_1_1Fysom.html#a47106a50e06d152cbd5ee6f5ff4d58c0">More...</a><br /></td></tr>
<tr class="separator:a47106a50e06d152cbd5ee6f5ff4d58c0 inherit pub_methods_classcore_1_1FysomAdapter_1_1Fysom"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232aa4fde5460b790d68fd6504415a80 inherit pub_methods_classcore_1_1FysomAdapter_1_1Fysom"><td class="memItemLeft" align="right" valign="top"><a id="a232aa4fde5460b790d68fd6504415a80"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__getattr__</b> (self, name)</td></tr>
<tr class="separator:a232aa4fde5460b790d68fd6504415a80 inherit pub_methods_classcore_1_1FysomAdapter_1_1Fysom"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classcore_1_1base_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classcore_1_1base_1_1Base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classcore_1_1base_1_1Base.html">core.base.Base</a></td></tr>
<tr class="memitem:a9399c821e2e710366f808693a4e431cb inherit pub_static_methods_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcore_1_1base_1_1Base.html#a9399c821e2e710366f808693a4e431cb">identify</a> ()</td></tr>
<tr class="memdesc:a9399c821e2e710366f808693a4e431cb inherit pub_static_methods_classcore_1_1base_1_1Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return module id.  <a href="classcore_1_1base_1_1Base.html#a9399c821e2e710366f808693a4e431cb">More...</a><br /></td></tr>
<tr class="separator:a9399c821e2e710366f808693a4e431cb inherit pub_static_methods_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classcore_1_1base_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classcore_1_1base_1_1Base')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classcore_1_1base_1_1Base.html">core.base.Base</a></td></tr>
<tr class="memitem:a5f399d7de81b3bb7e445410c9281e5d8 inherit pub_attribs_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top"><a id="a5f399d7de81b3bb7e445410c9281e5d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>connector</b></td></tr>
<tr class="separator:a5f399d7de81b3bb7e445410c9281e5d8 inherit pub_attribs_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classcore_1_1base_1_1Base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcore_1_1base_1_1Base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classcore_1_1base_1_1Base.html">core.base.Base</a></td></tr>
<tr class="memitem:a2cf041f14e9fd91486e718be26480af1 inherit pub_static_attribs_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top"><a id="a2cf041f14e9fd91486e718be26480af1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sigStateChanged</b> = QtCore.Signal(object)</td></tr>
<tr class="separator:a2cf041f14e9fd91486e718be26480af1 inherit pub_static_attribs_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93866ab4ae1e6322ddce68fcfffae4f inherit pub_static_attribs_classcore_1_1base_1_1Base"><td class="memItemLeft" align="right" valign="top"><a id="ab93866ab4ae1e6322ddce68fcfffae4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>result</b></td></tr>
<tr class="separator:ab93866ab4ae1e6322ddce68fcfffae4f inherit pub_static_attribs_classcore_1_1base_1_1Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>stable Kay Jahnke, Alexander Stark </p>
<p>A National Instruments device that can count and control microvave generators.</p>
<p>Basic procedure how the NI card is configurated:</p><ul>
<li>At first you have to define a channel, where the APD clicks will be received. That can be any PFI input, which is specified to record TTL pulses.</li>
<li>Then two counter channels have to be configured.</li>
<li>One counter channel serves as a timing device, i.e. basically a clock which runs at a certain given frequency.</li>
<li>The second counter channel will be used as a gated counting device, which will, dependent on the clock, count within the clock interval. The faster the clock channel is configured, the smaller is the gated counting interval and the less counts per clock periode you will count.</li>
</ul>
<p>Therefore the whole issue is to establish a time based gated-counting channel.</p>
<p>Text Based NI-DAQmx Data Acquisition Examples: <a href="http://www.ni.com/example/6999/en/#ANSIC">http://www.ni.com/example/6999/en/#ANSIC</a></p>
<p>Explanation of the termology, which is used in the NI Card and useful to know in connection with our implementation:</p>
<p>Hardware-Timed Counter Tasks: Use hardware-timed counter input operations to drive a control loop. A really good explanation can be found in:</p>
<p><a href="http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/controlappcase4/">http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/controlappcase4/</a></p>
<dl class="section user"><dt>Terminals</dt><dd>A terminal is a named location where a signal is either generated (output or produced) or acquired (input or consumed). A terminal that can output only one signal is often named after that signal. A terminal with an input that can be used only for one signal is often named after the clock or trigger that the signal is used for. Terminals that are used for many signals have generic names such as RTSI, PXITrig, or PFI. </dd></dl>
<dl class="section user"><dt></dt><dd><a href="http://zone.ni.com/reference/en-XX/help/370466W-01/mxcncpts/terminal/">http://zone.ni.com/reference/en-XX/help/370466W-01/mxcncpts/terminal/</a> <a href="http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/termnames/">http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/termnames/</a></dd></dl>
<p>Ctr0Out, Ctr1Out, Ctr2Out, Ctr3Out: Terminals at the I/O connector where the output of counter 0, counter 1, counter 2, or counter 3 can be emitted. You also can use Ctr0Out as a terminal for driving an external signal onto the RTSI bus.</p>
<p>Ctr0Gate, Ctr1Gate, Ctr2Gate, Ctr3Gate: Terminals within a device whose purpose depends on the application. Refer to Counter Parts in NI-DAQmx for more information on how the gate terminal is used in various applications.</p>
<p>Ctr0Source, Ctr1Source, Ctr2Source, Ctr3Source: Terminals within a device whose purpose depends on the application. Refer to Counter Parts in NI-DAQmx for more information on how the source terminal is used in various applications.</p>
<p>Ctr0InternalOutput, Ctr1InternalOutput, Ctr2InternalOutput, </p><dl class="section user"><dt>Ctr3InternalOutput</dt><dd>Terminals within a device where you can choose the pulsed or toggled output of the counters. Refer to Counter Parts in NI-DAQmx (or MAX) for more information on internal output terminals.</dd></dl>
<p>Task State Model: NI-DAQmx uses a task state model to improve ease of use and speed up driver performance. Have a look at</p>
<p><a href="http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/taskstatemodel/">http://zone.ni.com/reference/en-XX/help/370466V-01/mxcncpts/taskstatemodel/</a></p>
<p>Small The task state model consists of five states</p><ol type="1">
<li>Unverified,</li>
<li>Verified,</li>
<li>Reserved,</li>
<li>Committed,</li>
<li>Running. You call the Start Task function/VI, Stop Task function/VI, and Control Task function/VI to transition the task from one state to another. The task state model is very flexible. You can choose to interact with as little or as much of the task state model as your application requires.</li>
</ol>
<p>Device limitations: Keep in mind that ONLY the X-series of the NI cards is capable of doing a Counter Output Pulse Frequency Train with finite numbers of samples by using ONE internal device channel clock (that is the function DAQmxCreateCOPulseChanFreq or CO Pulse Freq in Labview)! All other card series have to use two counters to generate that! Check out the description of NI which tells you 'How Many Counters Does Each Type of Counter Input or Output Task Take':</p>
<p><a href="http://digital.ni.com/public.nsf/allkb/9D1780F448D10F4686257590007B15A8">http://digital.ni.com/public.nsf/allkb/9D1780F448D10F4686257590007B15A8</a></p>
<p>This code was tested with NI 6323 and NI 6229, where the first one is an X-series device and the latter one is a Low-Cost M Series device. With the NI 6229 it is not possible at all to perform the scanning task unless you have two of that cards. The limitation came from a lack of internal counters. The NI 6323 was taken as a basis for this hardware module and thus all the function are working on that card. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a30fbd314b886f771c0d58e6746a7bc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fbd314b886f771c0d58e6746a7bc48">&#9670;&nbsp;</a></span>close_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanner</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the clock and cleans up afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bool</td><td>scanner: specifies if the counter- or scanner- function should be used to close the device. True = scanner False = counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a7489c1f4e1516f04c319d39247f507c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7489c1f4e1516f04c319d39247f507c1">&#9670;&nbsp;</a></span>close_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanner</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the counter or scanner and cleans up afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bool</td><td>scanner: specifies if the counter- or scanner- function will be excecuted to close the device. True = scanner False = counter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="aec8ac2d05ff4c01cdd024a67d14cccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8ac2d05ff4c01cdd024a67d14cccdb">&#9670;&nbsp;</a></span>close_gated_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_gated_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear tasks, so that counters are not in use any more. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="af6765f3ec111dcc765cdac26cf1bf79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6765f3ec111dcc765cdac26cf1bf79b">&#9670;&nbsp;</a></span>close_odmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_odmr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the odmr and cleans up afterwards. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a5530f85f593dc7ac6ade6b8f65daf08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5530f85f593dc7ac6ade6b8f65daf08e">&#9670;&nbsp;</a></span>close_odmr_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_odmr_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the odmr and cleans up afterwards. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="adbe2b8405fd455020ed0da8ace0980f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe2b8405fd455020ed0da8ace0980f7">&#9670;&nbsp;</a></span>close_scanner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_scanner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the scanner and cleans up afterwards. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a52a964bbf1d3f2ddd6726f0cd85ab0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a964bbf1d3f2ddd6726f0cd85ab0fb">&#9670;&nbsp;</a></span>close_scanner_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.close_scanner_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the clock and cleans up afterwards. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a3389d0ffc952031893cd55e52d110a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3389d0ffc952031893cd55e52d110a97">&#9670;&nbsp;</a></span>count_odmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.count_odmr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sweeps the microwave and returns the counts on that sweep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>length: length of microwave sweep in pixel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float[]: the photon counts per second </dd></dl>

</div>
</div>
<a id="a94351394f0e7a270787bc8fdc304eb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94351394f0e7a270787bc8fdc304eb6e">&#9670;&nbsp;</a></span>get_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_constraints </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hardware limits of NI device. </p>
<dl class="section return"><dt>Returns</dt><dd>SlowCounterConstraints: constraints class for slow counter</dd></dl>
<p>FIXME ask hardware for limits when module is loaded </p>

</div>
</div>
<a id="a6789bd4425a4acb2c625df91a319dc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6789bd4425a4acb2c625df91a319dc11">&#9670;&nbsp;</a></span>get_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current counts per second of the counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>samples: if defined, number of samples to read in one go. How many samples are read per readout cycle. The readout frequency was defined in the counter setup. That sets also the length of the readout array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float [samples]: array with entries as photon counts per second </dd></dl>

</div>
</div>
<a id="a8f349fb7f6461c49bef0cf251371768a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f349fb7f6461c49bef0cf251371768a">&#9670;&nbsp;</a></span>get_counter_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_counter_channels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of counter channel names. </p>
<dl class="section return"><dt>Returns</dt><dd>tuple(str): channel names</dd></dl>
<p>Most methods calling this might just care about the number of channels, though. </p>

</div>
</div>
<a id="a412e89ef7d0a305937c31eaf5f0924d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412e89ef7d0a305937c31eaf5f0924d2">&#9670;&nbsp;</a></span>get_gated_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_gated_counts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>samples</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_available_samples</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns latest count samples acquired by gated photon counting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>samples: if defined, number of samples to read in one go. How many samples are read per readout cycle. The readout frequency was defined in the counter setup. That sets also the length of the readout array. </td></tr>
    <tr><td class="paramname">int</td><td>timeout: Maximal timeout for the read process. Since nidaq waits for all samples to be acquired, make sure this is long enough. </td></tr>
    <tr><td class="paramname">bool</td><td>read_available_samples : if False, NiDaq waits for the sample you asked for to be in the buffer before, True it returns what is in buffer until 'samples' is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5267dc97a7819a87e23395d626ae683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5267dc97a7819a87e23395d626ae683">&#9670;&nbsp;</a></span>get_position_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_position_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the physical range of the scanner. </p>
<dl class="section return"><dt>Returns</dt><dd>float [4][2]: array of 4 ranges with an array containing lower and upper limit. The unit of the scan range is micrometer. </dd></dl>

</div>
</div>
<a id="a75e69f8e8b6f8131b8faf37f77408d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e69f8e8b6f8131b8faf37f77408d5b">&#9670;&nbsp;</a></span>get_scanner_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_scanner_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current position of the scanner hardware. </p>
<dl class="section return"><dt>Returns</dt><dd>float[]: current position in (x, y, z, a). </dd></dl>

</div>
</div>
<a id="a313f64947f81d58fbc86691a78a54162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313f64947f81d58fbc86691a78a54162">&#9670;&nbsp;</a></span>get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.get_status </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives the current status of the Fast Counter and outputs it as return value. </p>
<p>0 = unconfigured 1 = idle 2 = running 3 = paused -1 = error state </p>

</div>
</div>
<a id="a1c977276c23510dda2aeff3d3a9432bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c977276c23510dda2aeff3d3a9432bf">&#9670;&nbsp;</a></span>on_activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.on_activate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts up the NI Card at activation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>e: Event class object from Fysom. An object created by the state machine module Fysom, which is connected to a specific event (have a look in the Base Class). This object contains the passed event, the state before the event happened and the destination of the state which should be reached after the event had happened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a711d4ab0dff688ccbc343d292a68a4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711d4ab0dff688ccbc343d292a68a4af">&#9670;&nbsp;</a></span>on_deactivate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.on_deactivate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down the NI card. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>e: Event class object from Fysom. A more detailed explanation can be found in method activation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ad424a77445bdea11026484c137ad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad424a77445bdea11026484c137ad89">&#9670;&nbsp;</a></span>reset_hardware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.reset_hardware </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the NI hardware, so the connection is lost and other programs can access it. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a50a215848497ac630fd2ce74f344f3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a215848497ac630fd2ce74f344f3c2">&#9670;&nbsp;</a></span>scan_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.scan_line </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>line_path</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans a line and return the counts on that line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float[][n]</td><td>line_path: array of n-part tuples defining the voltage points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float[]: the photon counts per second</dd></dl>
<p>The input array looks for a xy scan of 5x5 points at the position z=-2 like the following: [ [1, 2, 3, 4, 5], [1, 1, 1, 1, 1], [-2, -2, -2, -2] ] n is the number of scanner axes, which can vary. Typical values are 2 for galvo scanners, 3 for xyz scanners and 4 for xyz scanners with a special function on the a axis. </p>

</div>
</div>
<a id="a4f68689c37ed37d9a1499720030c87d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f68689c37ed37d9a1499720030c87d8">&#9670;&nbsp;</a></span>scanner_set_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.scanner_set_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>z</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move stage to x, y, z, a (where a is the fourth voltage channel). </p>
<p>#FIXME: No volts </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>x: postion in x-direction (volts) </td></tr>
    <tr><td class="paramname">float</td><td>y: postion in y-direction (volts) </td></tr>
    <tr><td class="paramname">float</td><td>z: postion in z-direction (volts) </td></tr>
    <tr><td class="paramname">float</td><td>a: postion in a-direction (volts)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a31ea0874c5f480cbae928ad067844bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ea0874c5f480cbae928ad067844bf5">&#9670;&nbsp;</a></span>set_odmr_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_odmr_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the trigger sequence for the ODMR and the triggered microwave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>length: length of microwave sweep in pixel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a526922b67a75bb1a023a28b8b0dc3e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526922b67a75bb1a023a28b8b0dc3e2a">&#9670;&nbsp;</a></span>set_position_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_position_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>myrange</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the physical range of the scanner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>[4][2] myrange: array of 4 ranges with an array containing lower and upper limit. The unit of the scan range is micrometer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="aa4e1697039257ef32c6324bd958942c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e1697039257ef32c6324bd958942c0">&#9670;&nbsp;</a></span>set_up_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_frequency</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanner</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idle</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the hardware clock of the NiDAQ card to give the timing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>clock_frequency: if defined, this sets the frequency of the clock in Hz </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: if defined, this is the physical channel of the clock within the NI card. </td></tr>
    <tr><td class="paramname">bool</td><td>scanner: if set to True method will set up a clock function for the scanner, otherwise a clock function for a counter will be set. </td></tr>
    <tr><td class="paramname">bool</td><td>idle: set whether idle situation of the counter (where counter is doing nothing) is defined as True = 'Voltage High/Rising Edge' False = 'Voltage Low/Falling Edge'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ac3fc37611b383c9229731c689acb2ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fc37611b383c9229731c689acb2ea6">&#9670;&nbsp;</a></span>set_up_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>counter_channels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sources</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>counter_buffer</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the actual counter with a given clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list(str)</td><td>counter_channels: optional, physical channel of the counter </td></tr>
    <tr><td class="paramname">list(str)</td><td>sources: optional, physical channel where the photons are to count from </td></tr>
    <tr><td class="paramname">str</td><td>clock_channel: optional, specifies the clock channel for the counter </td></tr>
    <tr><td class="paramname">int</td><td>counter_buffer: optional, a buffer of specified integer length, where in each bin the count numbers are saved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ad621cb56e4adc8997deba3908eb785e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad621cb56e4adc8997deba3908eb785e2">&#9670;&nbsp;</a></span>set_up_gated_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_gated_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>buffer_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>read_available_samples</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and starts task for external gated photon counting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>buffer_length: Defines how long the buffer to be filled with samples should be. If buffer is full, program crashes, so use upper bound. Some reference calculated with sample_rate (in Samples/second) divided by Buffer_size: sample_rate/Buffer_size = no rate / 10kS, (0-100S/s) / 10kS (101-10kS/s)/ 1kS, (10k-1MS/s) / 100kS, (&gt;1MS/s) / 1Ms </td></tr>
    <tr><td class="paramname">bool</td><td>read_available_samples: if False, NiDaq waits for the sample you asked for to be in the buffer before, if True it returns what is in buffer until 'samples' is full </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0358c76eabd9006917705f7dd117d8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0358c76eabd9006917705f7dd117d8de">&#9670;&nbsp;</a></span>set_up_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_line </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the analog output for scanning a line. </p>
<p>Connect the timing of the Analog scanning task with the timing of the counting task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>length: length of the line in pixel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ab0e1375b5aed38672390ca6ea36b63d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e1375b5aed38672390ca6ea36b63d8">&#9670;&nbsp;</a></span>set_up_odmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_odmr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>counter_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>photon_source</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>odmr_trigger_channel</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the actual counter with a given clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>counter_channel: if defined, this is the physical channel of the counter </td></tr>
    <tr><td class="paramname">string</td><td>photon_source: if defined, this is the physical channel where the photons are to count from </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: if defined, this specifies the clock for the counter </td></tr>
    <tr><td class="paramname">string</td><td>odmr_trigger_channel: if defined, this specifies the trigger output for the microwave</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a39f12330aa92f2c7e4e0a3c95e702764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f12330aa92f2c7e4e0a3c95e702764">&#9670;&nbsp;</a></span>set_up_odmr_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_odmr_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_frequency</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the hardware clock of the NiDAQ card to give the timing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>clock_frequency: if defined, this sets the frequency of the clock </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: if defined, this is the physical channel of the clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a816cadbc91ebe56757c85ec07fd44c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816cadbc91ebe56757c85ec07fd44c1c">&#9670;&nbsp;</a></span>set_up_scanner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_scanner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>counter_channels</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sources</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scanner_ao_channels</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the actual scanner with a given clock. </p>
<p>The scanner works pretty much like the counter. Here you connect a created clock with a counting task. That can be seen as a gated counting, where the counts where sampled by the underlying clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list(str)</td><td>counter_channels: this is the physical channel of the counter </td></tr>
    <tr><td class="paramname">list(str)</td><td>sources: this is the physical channel where the photons are to count from </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: optional, if defined, this specifies the clock for the counter </td></tr>
    <tr><td class="paramname">list(str)</td><td>scanner_ao_channels: optional, if defined, this specifies the analog output channels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ad588ef812b7f227eba9a356d1bd97ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad588ef812b7f227eba9a356d1bd97ef6">&#9670;&nbsp;</a></span>set_up_scanner_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_up_scanner_clock </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_frequency</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clock_channel</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the hardware clock of the NiDAQ card to give the timing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>clock_frequency: if defined, this sets the frequency of the clock </td></tr>
    <tr><td class="paramname">string</td><td>clock_channel: if defined, this is the physical channel of the clock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="a86f1ffa246fac47565b6624b489ca0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f1ffa246fac47565b6624b489ca0ba">&#9670;&nbsp;</a></span>set_voltage_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.set_voltage_range </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>myrange</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the voltage range of the NI Card. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">float</td><td>[n][2] myrange: array containing lower and upper limit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="abdcfaa68c2c22e133b7e88eec6aaef81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcfaa68c2c22e133b7e88eec6aaef81">&#9670;&nbsp;</a></span>start_gated_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.start_gated_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actually start the preconfigured counter task. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<a id="ad020dd3cb95dd98cb2524f2f4369ba73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad020dd3cb95dd98cb2524f2f4369ba73">&#9670;&nbsp;</a></span>stop_gated_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ni_card.NICard.stop_gated_counter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actually start the preconfigured counter task. </p>
<dl class="section return"><dt>Returns</dt><dd>int: error code (0:OK, -1:error) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hardware/ni_card.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
